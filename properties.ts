import { propertyValues } from './helper'
import { sizes } from './options'
import { Complex, type MultiSize, type Property } from './types'

const addDirections = (name: string, abbreviation: string, defaultValue: string | undefined = undefined) => ({
  [name]: [name, defaultValue],
  [abbreviation]: name,
  [`${name}Top`]: [`${name}Top`, defaultValue],
  [`${abbreviation}t`]: `${name}Top`,
  [`${name}Bottom`]: [`${name}Bottom`, defaultValue],
  [`${abbreviation}b`]: `${name}Bottom`,
  [`${name}Left`]: [`${name}Left`, defaultValue],
  [`${abbreviation}l`]: `${name}Left`,
  [`${name}Right`]: [`${name}Right`, defaultValue],
  [`${abbreviation}r`]: `${name}Right`,
})

const addAxes = (name: string, abbreviation: string, defaultValue: string | undefined = undefined) => ({
  [`${name}Vertical`]: [`${name}Vertical`, defaultValue],
  [`${abbreviation}v`]: `${name}Vertical`,
  [`${name}Horizontal`]: [`${name}Horizontal`, defaultValue],
  [`${abbreviation}h`]: `${name}Horizontal`,
})

const addCorners = (start: string, end: string, abbreviations: string[], defaultValue: string | undefined = undefined) => ({
  [`${start}${end}`]: [`${start}${end}`, defaultValue],
  ...abbreviations.reduce(
    (result, abbreviation) => {
      result[abbreviation] = `${start}${end}`
      return result
    },
    {} as Record<string, string>,
  ),
  [`${start}TopLeft${end}`]: [`${start}TopLeft${end}`, defaultValue],
  [`${abbreviations[0]}tl`]: `${start}TopLeft${end}`,
  [`${start}TopRight${end}`]: [`${start}TopRight${end}`, defaultValue],
  [`${abbreviations[0]}tr`]: `${start}TopRight${end}`,
  [`${start}BottomLeft${end}`]: [`${start}BottomLeft${end}`, defaultValue],
  [`${abbreviations[0]}bl`]: `${start}BottomLeft${end}`,
  [`${start}BottomRight${end}`]: [`${start}BottomRight${end}`, defaultValue],
  [`${abbreviations[0]}br`]: `${start}BottomRight${end}`,
  // Shortcuts like paddingHorizontal.
  [`${start}Top${end}`]: `${start}TopLeft${end}-${start}TopRight${end}`,
  [`${start}Bottom${end}`]: `${start}BottomLeft${end}-${start}BottomRight${end}`,
})

const bigSize = (size?: MultiSize) => (Array.isArray(size) ? size[0] : size) ?? 10
const smallSize = (size?: MultiSize) => (Array.isArray(size) ? size[1] : size) ?? 2

export const getProperties: () => { [key: string]: Property } = () => ({
  justifyContent: ['justifyContent', propertyValues.center],
  justify: 'justifyContent',
  centerHorizontal: `justifyContent-${propertyValues.center}`,
  centerVertical: `alignItems-${propertyValues.center}`,
  jc: `justifyContent-${propertyValues.center}`,
  between: `justifyContent-${propertyValues.spaceBetween}`,
  alignItems: ['alignItems', propertyValues.center],
  items: 'alignItems',
  alignContent: ['alignContent', propertyValues.normal],
  align: 'alignItems', // Using alignItems, as that's more common than alignContent.
  display: ['display', propertyValues.flex],
  flex: 'display',
  inlineFlex: `display-${propertyValues.inlineFlex}`,
  inline: 'inlineFlex',
  df: 'display',
  flexDirection: ['flexDirection', propertyValues.row],
  row: `flexDirection-${propertyValues.row}`,
  column: `flexDirection-${propertyValues.column}`,
  col: 'column',
  direction: 'flexDirection',
  flexWrap: ['flexWrap', propertyValues.wrap], // nowrap is the default.
  wrap: 'flexWrap',
  whiteSpace: ['whiteSpace', propertyValues.nowrap],
  nowrap: 'whiteSpace',
  gap: ['gap', sizes.medium],
  space: 'gap',
  columnGap: ['columnGap'],
  rowGap: ['rowGap'],
  order: ['order'],
  flex1: ['flex', '[1]'],
  flex0: ['flex', '[0]'],
  flexAuto: ['flex', propertyValues.auto],
  flexNone: ['flex', propertyValues.none],
  flexBasis: ['flexBasis', propertyValues.auto],
  basis: 'flexBasis',
  alignSelf: ['alignSelf', propertyValues.auto],
  self: 'alignSelf',
  overflow: ['overflow', propertyValues.auto],
  scroll: 'overflow',
  textOverflow: ['textOverflow', propertyValues.ellipsis],
  ellipsis: 'textOverflow',
  backgroundPosition: ['backgroundPosition', propertyValues.inherit],
  backgroundRepeat: ['backgroundRepeat', propertyValues.noRepeat],
  backgroundSize: ['backgroundSize', propertyValues.cover],
  fontFamily: ['fontFamily', propertyValues.sansSerif],
  font: 'fontFamily',
  mono: `fontFamily-${propertyValues.monospace}`,
  serif: `fontFamily-${propertyValues.serif}`,
  sansSerif: 'fontFamily',
  sans: 'fontFamily',
  fontWeight: ['fontWeight', propertyValues.normal],
  italic: `fontStyle-${propertyValues.italic}`,
  bold: `fontWeight-${propertyValues.bold}`,
  outline: ['outline', propertyValues.none],
  noOutline: 'outline-none',
  outlineColor: ['outlineColor', 'black'],
  outlineWidth: ['outlineWidth', 1],
  outlineStyle: ['outlineStyle', 'solid'],
  textDecoration: ['textDecoration', propertyValues.none],
  visibility: ['visibility', propertyValues.hidden],
  hidden: 'visibility',
  visible: `visibility-${propertyValues.visible}`,
  aspectRatio: ['aspectRatio', propertyValues.auto],
  ratio: 'aspectRatio',
  position: ['position', propertyValues.static],
  relative: `position-${propertyValues.relative}`,
  absolute: `position-${propertyValues.absolute}`,
  fixed: `position-${propertyValues.fixed}`,
  sticky: `position-${propertyValues.sticky}`,
  boxSizing: ['boxSizing', propertyValues.borderBox],
  borderBox: 'boxSizing',
  box: 'boxSizing',
  cursor: ['cursor', propertyValues.pointer],
  noCursor: ['cursor', propertyValues.auto],
  pointerEvents: ['pointerEvents', propertyValues.none],
  flexGrow: ['flexGrow', '[0]'],
  grow: 'flexGrow',
  flexShrink: ['flexShrink', '[1]'],
  shrink: 'flexShrink',
  ...addCorners('border', 'Radius', ['r', 'radius', 'br'], sizes.medium),
  rounded: 'borderRadius',
  background: ['background'],
  bg: 'background',
  backgroundColor: ['backgroundColor'],
  color: ['color'],
  width: ['width'],
  w: 'width',
  fullWidth: ['width', '100%'],
  maxWidth: ['maxWidth'],
  maxW: 'maxWidth',
  minWidth: ['minWidth'],
  minW: 'minWidth',
  fullHeight: ['height', '100%'],
  maxHeight: ['maxHeight'],
  maxH: 'maxHeight',
  minHeight: ['minHeight', '100vh'],
  minH: 'minHeight',
  height: ['height'],
  h: 'height',
  ...addDirections('padding', 'p', sizes.medium),
  ...addAxes('padding', 'p', sizes.medium),
  ...addDirections('margin', 'm', sizes.medium),
  ...addAxes('margin', 'm', sizes.medium),
  ...addDirections('border', 'b', propertyValues.none),
  ...addAxes('border', 'b', propertyValues.none),
  border: ['border', '[1px solid black]'],
  noBorder: 'border-none',
  borderColor: ['borderColor', 'black'],
  borderWidth: ['borderWidth', 1],
  borderStyle: ['borderStyle', 'solid'],
  textAlign: ['textAlign', 'center'],
  text: 'textAlign',
  fontSize: ['fontSize', sizes.medium],
  fs: 'fontSize',
  fontStyle: ['fontStyle', propertyValues.normal],
  weight: 'fontWeight',
  decoration: 'textDecoration',
  square: 'aspectRatio-[1]',
  aspect: 'aspectRatio',
  top: ['top', 0],
  right: ['right', 0],
  bottom: ['bottom', 0],
  left: ['left', 0],
  inset: ['inset', 0],
  tp: 'top',
  ri: 'right',
  bt: 'bottom',
  lt: 'left',
  appearance: ['appearance', propertyValues.none],
  flip: ['transform', '[scale(-1,-1)]'],
  flipHorizontal: ['transform', '[scale(-1,1)]'],
  flipVertical: ['transform', '[scale(1,-1)]'],
  objectFit: ['objectFit', propertyValues.cover],
  zIndex: ['zIndex', propertyValues.auto],
  layer: 'zIndex',
  // Deprecated, non-standard properties.
  lineClamp: ['WebkitLineClamp', '1'],
  boxOrient: ['WebkitBoxOrient', 'vertical'],
  webKitBox: ['display', propertyValues.webkitBox],
  // CSS Grid
  grid: `display-${propertyValues.grid}`,
  gridTemplateRows: ['gridTemplateRows', propertyValues.none],
  gridTemplateColumns: ['gridTemplateColumns', propertyValues.none],
  gridRow: ['gridRow', 'auto'],
  gridColumn: ['gridColumn', 'auto'],
  boxShadow: ['boxShadow', propertyValues.none],
  textShadow: ['textShadow', propertyValues.none],
  resize: ['resize', propertyValues.none],
  // Complex properties (dynamically calculated).
  boxShadowX: [
    'boxShadow',
    ({ size, color = '#000000AA' }) =>
      `0 ${Math.round(bigSize(size) / 2)}px ${Math.round(bigSize(size) / 2)}px ${Math.round(bigSize(size) / 4)}px ${color}`,
  ],
  shadow: 'boxShadowX',
  textShadowX: ['textShadow', ({ size, color = 'black' }) => `${smallSize(size)}px ${smallSize(size)}px ${smallSize(size)}px ${color}`],
  scale: ['transform', ({ arbitrary = '0.5' }) => `scale(${arbitrary})`],
  scaleY: ['transform', ({ arbitrary = '0.5' }) => `scaleY(${arbitrary})`],
  innerRadius: [
    'WebkitMaskImage',
    ({ size }) =>
      `radial-gradient(circle ${bigSize(size)}px at 0 0, transparent 0, transparent ${bigSize(size) * 2}px, black ${bigSize(size) * 2 + 1}px)`,
  ],
  // TODO complex with Complex.multiple, was size[0][0], size[1][1]
  multiple: ['transform', ({ size }) => `${bigSize(size)}-${smallSize(size)}`, Complex.Multiple],
})

export const getShortcuts = () => ({
  button: 'outline noBorder cursor background-none',
  input: 'outline noBorder',
  link: 'decoration color-inherit',
  normal: 'margin-0', // Normalize headings and p.
  marginX: 'marginLeft marginRight', // Common old way to center items.
  mx: 'marginX',
  paddingX: 'paddingLeft paddingRight',
  px: 'paddingX',
  paddingY: 'paddingTop paddingBottom',
  py: 'paddingY',
  code: 'mono bg-lightgray p-3 radius-3',
  borderTopRadius: 'borderTopLeftRadius borderTopRightRadius',
  borderBottomRadius: 'borderBottomLeftRadius borderBottomRightRadius',
  center: 'centerHorizontal centerVertical',
  singleLineText: 'overflow-hidden nowrap ellipsis display-initial',
  // Deprecated, non-standard properties.
  webKitEllipsis: 'overflow-hidden lineClamp boxOrient webKitBox',
})
